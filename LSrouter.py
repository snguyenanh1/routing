import json
from packet import Packet
import networkx as nx

from router import Router

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.MAX_COST = float("inf")
        self.seq_num = 0
        self.neighbors = {}
        self.ls_db = {
            self.addr: {
                'seq_num': self.seq_num,
                'links': {}
            }
        }
        self.routing_table = {self.addr: None}
        self.graph = nx.Graph()

    def update(self):
        self.graph.clear()
        all_nodes = set()

        for router, lsa_data in self.ls_db.items():
            all_nodes.add(router)
            if 'links' in lsa_data:
                for neigh, cost in lsa_data['links'].items():
                    all_nodes.add(neigh)
                    if cost < self.MAX_COST:
                        self.graph.add_edge(router, neigh, weight=cost)
        
        for info in self.neighbors.values():
            all_nodes.add(info['addr'])
            if info['addr'] not in self.ls_db:
                if info['cost'] < self.MAX_COST:
                    self.graph.add_edge(self.addr, info['addr'], weight=info['cost'])

        if not self.addr in self.graph:
            return

        new_routes = {self.addr: None}
        paths = nx.single_source_dijkstra_path(self.graph, self.addr)

        for dest in paths:
            if dest == self.addr:
                continue
            if len(paths[dest]) > 1:
                next_hop = paths[dest][1]          
                port = None
                for p, info in self.neighbors.items():
                    if info['addr'] == next_hop:
                        port = p
                        break            
                if port is not None:
                    new_routes[dest] = port

        self.routing_table = new_routes

    def broadcast_lsa(self, lsa, from_port=None):
        lsa_str = json.dumps(lsa) 
        for port, info in self.neighbors.items():
            if from_port is not None and port == from_port:
                continue
            neigh_addr = info['addr']
            packet = Packet(kind=Packet.ROUTING, 
                          src_addr=self.addr,
                          dst_addr=neigh_addr,
                          content=lsa_str)       
            self.send(port, packet)

        
    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            pass
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            pass

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.neighbors[port] = {'addr': endpoint, 'cost': cost}
        self.seq_num += 1
        lsa = self.create_lsa()
        self.ls_db[self.addr] = {
            'seq_num': lsa['seq_num'],
            'links': lsa['links']
        }
        self.update()
        self.broadcast_lsa(lsa)
        

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        if port in self.neighbors:
            del self.neighbors[port]
            self.seq_num += 1
            lsa = self.create_lsa()
            self.ls_db[self.addr] = {
                'seq_num': lsa['seq_num'],
                'links': lsa['links']
            }
            
            self.update() 
            self.broadcast_lsa(lsa)

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            lsa = self.create_lsa()
            self.broadcast_lsa(lsa)
        

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"